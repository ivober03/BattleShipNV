"""
The AI class represents the AI opponent in the game.
It's responsible for generating its own game board and placing its ships randomly.

The AI will make decisions on where to guess based on the information provided in the sentences and its strategies.

"""
from .constants import *
from .ship import *
from .sentence import *
import random

class OpponentAI:
    """
    Represents a ship object in the game.
    """

    # Define a class-level variable to store the AI modes
    POSSIBLE_MODES = ["Target", "Hunt"]

    def __init__ (self, board, user):
        """
        Constructor for the AI class.
        """

        self.board = board
        self.ships = []
        self.opponent = user

        # AI state variables
        self.mode = OpponentAI.POSSIBLE_MODES[0]
        self.moves_made = set() # List of the moves made 
        self.sunked_ships = set() # List of the sunked ships
        self.knowledge = set() # List of potential targets
        self.current_target = set() # List of the cells of the current target
        self.cleansed_knowledge = True 

        self.possible_parities = [2,3,4,5]
        self.parity = self.possible_parities[0] # Set the default parity to be the lowest one
        

    def get_board(self):
        return self.board
    

    def ask_if_hit(self, row, col):
        """
        Returns true if the cell passed as a parameter contains a ship
        """     
        return self.board.get_cell(row, col).is_ship


    def generate_coords(self, length):
        """
        Generates a random set of coordinates, ensuring they are consecutive and do not contain a ship.
        """

        while True:
            # Determine the direction (horizontal or vertical) randomly.
            orientation = random.choice(['vertical', 'horizontal'])

            # Randomly select the starting position.
            if orientation == 'horizontal':
                start_row = random.randint(0, 9 - 1)
                start_col = random.randint(0, 9 - length)
            else:
                start_row = random.randint(0, 9 - length)
                start_col = random.randint(0, 9 - 1)

            # Generate consecutive coordinates based on the chosen direction.
            coords = []
            for i in range(length):
                if orientation == 'horizontal':
                    coords.append((start_row, start_col + i))
                else:
                    coords.append((start_row + i, start_col))

            # Check if the generated coordinates contain any cells with ships.
            has_ship = any(self.board.get_cell(row, col).is_ship() for row, col in coords)

            # If there are no ships in the generated coordinates, return them.
            if not has_ship:
                return coords


    def place_ship(self, win, length):
        """
        Places AI ship on the game board using coordinates generated by generate_coords.
        """

        coords = self.generate_coords(length)

        temp_cells = []
        for (row, col) in coords:
            temp_cells.append(self.board.get_cell(row, col))

        ship = Ship(temp_cells)  # Creates the ship
        self.board.draw_ship(win, ship)
        self.ships.append(ship)  # Stores all the AI ships
        self.board.update_board()
        
        return ship


    def get_orientation(self, cell_1, cell_2):
        """
        Determine the orientation of the ship based on two cells.
        Returns 'horizontal' if the ship is horizontally placed,
        'vertical' if the ship is vertically placed.
        """
        x1, y1 = cell_1
        x2, y2 = cell_2

        if x1 == x2:
            return 'vertical'  # The ship is vertically placed
        elif y1 == y2:
            return 'horizontal'  # The ship is horizontally placed
        else:
            return 'unknown'  # The orientation is unknown
        

    def get_orientation_from_current_target(self):
        """
        Determine the orientation of the ship based on two random cells from the self.current_target set.
        Returns 'horizontal' if the ship is horizontally placed,
        'vertical' if the ship is vertically placed.
        """

        if not self.current_target or len(self.current_target) < 2:
            # Handle the case when the current_target set is empty or has less than 2 cells
            return None

        # Convert the current_target set to a list before using random.sample
        current_target_list = list(self.current_target)

        # Randomly select two cells from the current_target list
        cell_1, cell_2 = random.sample(current_target_list, 2)

        # Use the existing get_orientation method to determine the orientation
        return self.get_orientation(cell_1, cell_2)
    

    def get_ship_limits(self, cells):
        """
        Given a set of cells representing a boat, return the two cells that represent the limits of the boat.
        This method works for both vertical and horizontal boats.
        """

        if not cells:
            # Handle the case when the boat_cells set is empty
            return None, None

        # Initialize min and max coordinates for both rows and columns
        min_row, min_col = float('inf'), float('inf')
        max_row, max_col = -1, -1

        for cell in cells:
            row, col = cell
            # Update the min and max coordinates
            min_row = min(min_row, row)
            min_col = min(min_col, col)
            max_row = max(max_row, row)
            max_col = max(max_col, col)

        # Create the cells representing the boat limits
        min_cell = (min_row, min_col)
        max_cell = (max_row, max_col)

        return min_cell, max_cell
    

    def update_parity(self, ship):
        """
        Update parity set by the sunked ship.
        """ 

        size = ship.size
        possible_parities_copy = self.possible_parities.copy()  
        for parity in possible_parities_copy:
            if parity == size:
                self.possible_parities.remove(parity)
            break

        self.parity = self.possible_parities[0] # updates parity
        

    def clear_knowledge(self, orientation, limits):
        """
        Once the AI knows the orientation of the current target, removes from self.knowledge the cells wich are known to not be from that ship.
        """
        
        knowledge = set()
        cell_1, cell_2 = limits

        for cell in self.knowledge:
            cell_orientation = self.get_orientation(cell, cell_1)

            if cell_orientation == orientation:
            # The cell is consistent with the known ship orientation
                knowledge.add(cell)
        
        self.knowledge = knowledge


    def target_mode(self):
        """
        Enter target mode once a ship is hit, then:
        1- From the knowledge set:
            1.a- Select the first cell from the set and fire to its location.
            1.b- Modify the sentence according to the result of the previous move:
                * if the guess was a hit, create a new sentence with the two bordering cells.********
                * else delete that cell from the knowledge set
        """

        knowledge = list(self.knowledge.copy()) # Create a copy of the knowledge set and transform it into a list      
        cell = knowledge[0]
        hit = False

        if cell not in self.moves_made:
            row, col = cell
            hit = self.opponent.ask_if_hit(row, col)
            self.moves_made.add(cell)

            if hit:
                self.current_target.add(cell) # If the guess was a hit add that cell to the current target set

                orientation = self.get_orientation_from_current_target()
                limits = self.get_ship_limits(self.current_target)

                new_knowledge = Sentence(None, orientation, self.moves_made, limits)  # Create new knowledge using the ship limits and its orientation

                self.knowledge.update(new_knowledge.cells)  # Add the cells from new knowledge
                print(f"AI's guess: {cell}, Hit: {hit}")
                print(f"Removing cell: {cell}")
                self.knowledge.remove(cell)

                if not self.cleansed_knowledge:
                    self.clear_knowledge(orientation, limits)
                    self.cleansed_knowledge = True

            else:
                print(f"AI's guess: {cell}, Hit: {hit}")
                print(f"Removing cell: {cell}")
                self.knowledge.remove(cell)

        else: 
            print(f"AI's guess: {cell}, Hit: {hit}")
            print(f"Removing cell: {cell}")
            self.knowledge.remove(cell)

        data = (hit, cell)
        return data
    

    def hunt_mode(self):
        """
        In Hunt mode, the AI will shoot at random coordinates with the corresponding parity
        (later on, the hunt mode will take into account the pdf_value of each cell,
        so it can redirect the movements to cells with the highest chance of having a ship)
        """

        cell = None

        while cell is None:
            row = random.randint(0, 9)  
            col = random.randint(0, 9) 

            if row % self.parity == 0 and col % self.parity == 0:
                if (row, col) not in self.moves_made:
                    cell = row, col  # Store cell
                    self.moves_made.add(cell)  # Add the cell to the moves made set

        # Check if the cell contains a ship part
        hit = self.opponent.ask_if_hit(cell[0], cell[1])
        
        if hit:
            self.current_target.add(cell)  # If the guess was a hit, add that cell to the current target set

        data = (hit, cell)

        return data


    def make_guess(self): 
        """
        Makes a guess: at first the AI will start in 'Hunt' mode. 
        Once a ship is touched, the inferences will be put into the sentence and the AI ​​will enter 'target' mode
        """
        
        is_a_hit = False
        cell = None

        # if there is no knowledge about possible targets, enter 'Hunt' mode
        if not self.knowledge:

            is_a_hit, cell = self.hunt_mode()

            # If the guess shit a ship, add new knowledge
            if is_a_hit:
                # Construct a new Sentence object and update knowledge
                new_knowledge = Sentence(cell, None, self.moves_made, None)
                self.knowledge.update(new_knowledge.cells)  # Add the cells from new knowledge
                if self.cleansed_knowledge:
                    self.cleansed_knowledge = False

        # if there is knowledge about possible targets, enter 'Target' mode
        else:
            is_a_hit, cell = self.target_mode()
            # Check if the ship is sunken:
            if is_a_hit:
                sunken =  self.opponent.ask_if_sunken(cell)
                if sunken:
                    ship = self.opponent.get_ship(cell)
                    self.sunked_ships.add(ship)
                    self.update_parity(ship) # Updates the parity taking into account the sunked ship
                    self.knowledge.clear()
                    print("-----------------------------------------")
                    print(f"{ship.type} succesfully sunken.")
                    print(f"Parity set: {self.possible_parities}")
                    print(f"Current parity: {self.parity}")
                    print("Cleaning knowledge ...")
        
        data = (is_a_hit, cell)
        return data